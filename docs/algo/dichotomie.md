# Algorithmes de recherche dichotomique ðŸ”ª

??? conclu "Programme"
	|Notions|CompÃ©tences|Remarques|
	|--|--|--|
    Recherche dichotomique dans un tableau triÃ© | Montrer la terminaison de la recherche dichotomique Ã  lâ€™aide dâ€™un variant de boucle. | Des assertions peuvent Ãªtre utilisÃ©es.<br>La preuve de la correction peut Ãªtre prÃ©sentÃ©e par le professeur.

{{exercice(prem=1, titre="Je joue contre l'ordinateur")}}

    === "Question 1"

        ExÃ©cuter le programme du jeu du nombre mystÃ¨re.
        Faire quelques parties, expliquer la stratÃ©gie de l'ordinateur pour trouver le nombre mystÃ¨re.

        {{ IDE('scripts/mystere') }} 

        ??? success "Solution"

                A chaque fois, il se place au milieu.

    === "Question 2"

        Lorsque le nombre est compris entre 1 et 100, en combien d'essais au maximum l'ordinateur trouve-t-il la solution ?

        ??? success "Solution"

            En 7 essais.

    === "Question 3"

        Et si le nombre mystÃ¨re est compris entre 1 et 200 ?

        ??? success "Solution"

            En 8 essais.


??? info "DÃ©finition et principe de la dichotomie"

    Le mot dichotomie vient du grec ancien Î´Î¹Ï‡Î¿Ï„Î¿Î¼Î¯Î±, dikhotomia (Â« division en deux parties Â»).

    La mÃ©thode de dichotomie fait partie des mÃ©thodes dites *Â«diviser pour rÃ©gnerÂ»*. 

    Â«dichotomieÂ» se dit en anglais *binary search*.

    !!! note "Dichotomie, dÃ©roulement intuitif"
        - on se place *au milieu* de la liste.
        - on regarde si la valeur sur laquelle on est placÃ©e est infÃ©rieure ou supÃ©rieure Ã  la valeur cherchÃ©e.
        - on ne considÃ¨re maintenant que la bonne moitiÃ© de la liste qui nous intÃ©resse.
        - on continue jusqu'Ã  trouver la valeur cherchÃ©e (ou pas)



    Comprendre la mÃ©thode de dichotomie est relativement simple, mais savoir la programmer est plus difficile.

    Pour des raisons d'efficacitÃ©, nous allons garder *intacte* notre liste de travail et simplement faire Ã©voluer les indices qui dÃ©terminent le dÃ©but et la fin de notre liste.

    Une autre mÃ©thode pourrait Ãªtre d'extraire Ã  chaque Ã©tape une nouvelle liste (dont on espÃ¨re qu'elle contient la valeur cherchÃ©e), mais la technique utilisÃ©e (le *slicing* de liste) consomme beaucoup trop de ressources.

    Nous allons donc travailler avec trois variables :

    - `indice_debut` (en bleu sur le schÃ©ma)
    - `indice_fin` (en bleu sur le schÃ©ma)
    - `indice_central`, qui est Ã©gale Ã  `(indice_debut + indice_fin) // 2` (en rouge sur le schÃ©ma)

    Dans cet exemple nous cherchons `14` dans la liste **triÃ©e** `[2, 3, 6, 7, 11, 14, 18, 19, 24]`.

    ![indices dichotomie](images/fig4.png){: .center}

    Nous allons faire *se rapprocher* les indices `indice_debut` et `indice_fin` **tant que** `indice_debut <= indice_fin`

{{exercice(titre="Recherche d'appartenance")}}

    ComplÃ©ter la fonction `appartient_dichotomique` qui prend en paramÃ¨tre une liste Python `ma_liste` et un valeur `valeur`. Cette fonction renvoie `True` si `valeur` est dans `ma_liste` et `False` sinon.

    {{ IDE('scripts/appartient_dicho') }}


{{exercice(titre="DÃ©roulÃ© Ã  la main : `v = 9` est-il dans `t = [1, 3, 6, 9]` ?")}}

    Ã‰crire le dÃ©roulÃ© Ã  la main. Voici le dÃ©but Ã  poursuivre de faÃ§on analogue : 

    * indice_debut = <font color="#cc7777"><b>0</b></font>
    * indice_fin = <font color="#cc7777"><b>3</b></font>
    * condition du while : <font color="#cc7777"><b>True</b></font>
    * indice_centre =  <font color="#cc7777">**(0+3)//2 = 1**</font>
    * valeur_centrale = ma_liste[indice_centre]  = <font color="#cc7777"><b>3</b></font>
    * v == valeur_centrale â†’ `False`
    * valeur_centrale < v â†’ `True`
    * indice_debut =  <font color="#cc7777">**2**</font>
    * condition du while : <font color="#cc7777"><b>True</b></font>
    * ...


    ??? success "Solution"

        * indice_debut = <font color="#cc7777"><b>0</b></font>
        * indice_fin = <font color="#cc7777"><b>3</b></font>
        * condition du while : <font color="#cc7777"><b>True</b></font>
        * indice_centre =  <font color="#cc7777">**(0+3)//2 = 1**</font>
        * valeur_centrale = ma_liste[indice_centre]  = <font color="#cc7777"><b>3</b></font>
        * v == valeur_centrale â†’ `False`
        * valeur_centrale < v â†’ `True`
        * indice_debut =  <font color="#cc7777">**2**</font>
        * condition du while : <font color="#cc7777"><b>True</b></font>
        * indice_centre =  <font color="#cc7777">**(2+3)//2 = 2**</font>
        * valeur_centrale = ma_liste[indice_centre]  = <font color="#cc7777"><b>6</b></font>
        * v == valeur_centrale â†’ `False`
        * valeur_centrale < v â†’ `True`
        * valeur_debut =  <font color="#cc7777">**3**</font>
        * condition du while : <font color="#cc7777"><b>True</b></font>
        * indice_centre =  <font color="#cc7777">**(3+3)//2 = 3**</font>
        * valeur_centrale = ma_liste[indice_centre]  = <font color="#cc7777"><b>9</b></font>
        * v == valeur_centrale â†’ `True`
        * la fonction renvoie `True`



{{exercice(titre="DÃ©roulÃ© Ã  la main : `v = 7` est-il dans `t = [1, 3, 6, 9, 10]` ?")}}

    Ã‰crire le dÃ©roulÃ© Ã  la main, comme dans l'exercice prÃ©cÃ©dent

    ??? success "Solution"

        * indice_debut = <font color="#cc7777"><b>0</b></font>
        * indice_fin = <font color="#cc7777"><b>4</b></font>
        * condition du while : <font color="#cc7777"><b>True</b></font>
        * indice_centre =  <font color="#cc7777">**(0+4)//2 = 2**</font>
        * valeur_centrale = ma_liste[indice_centre]  = <font color="#cc7777"><b>6</b></font>
        * v == valeur_centrale â†’ `False`
        * valeur_centrale < v â†’ `True`
        * indice_debut =  <font color="#cc7777">**3**</font>
        * condition du while : <font color="#cc7777"><b>True</b></font>
        * indice_centre =  <font color="#cc7777">**(3+4)//2 = 3**</font>
        * valeur_centrale = ma_liste[indice_centre]  = <font color="#cc7777"><b>9</b></font>
        * v == valeur_centrale â†’ `False`
        * valeur_centrale < v â†’ `False`
        * indice_fin =  <font color="#cc7777">**2**</font>
        * condition du while : <font color="#cc7777"><b>False</b></font>
        * la fonction renvoie `False`

        ðŸ‘‰ On voit dans cet exemple pourquoi l'instruction `while indice_debut <= indice_fin :` est **absolument nÃ©cessaire**.


{{exercice(titre="Recherche d'indice")}}

    ComplÃ©ter la fonction `recherche_dichotomique` qui prend en paramÃ¨tre une liste Python `ma_liste` et un valeur `valeur`. Cette fonction renvoie son indice si `valeur` est dans `ma_liste` et `None` sinon.

    {{ IDE('scripts/recherche_dicho') }}


{{exercice(titre="Une fÃªte")}}

    Nicolas organise une fÃªte, et demande Ã  ses amis s'ils viendront. DÃ¨s qu'un ami lui rÃ©pond favorablement, il l'ajoute dans `liste_amis`.
    ComplÃ©ter le code ci-dessous afin de pouvoir dÃ©terminer si Vincent, Romain et ValÃ©rie ont dÃ©cidÃ© de venir (bien respecter les majuscules, minuscules et accents). La liste `liste_amis` est dans du code cachÃ©.

    Vous devez **absolument** rÃ©aliser une recherche **dichotomique** et pas une recherche naÃ¯ve. Attention, c'est Ã  vous de crÃ©er `ma_liste_amis` qui est utilisÃ©e dans les tests. (Vous pouvez regader l'astuce plus bas, en cas de besoin)

    {{IDE('scripts/exo_dicho')}}

    ??? tip "Astuce"

        N'y-a-t-il pas une condition sur la liste dans laquelle on rÃ©alise la recherche dichotomique ?
            

    ??? success "Solution pour Vincent, Romain et ValÃ©rie"

        ```pycon
        >>> appartient_dichotomique(ma_liste_amis, "Vincent")
        False
        >>> appartient_dichotomique(ma_liste_amis, "Romain")
        False
        >>> appartient_dichotomique(ma_liste_amis, "ValÃ©rie")
        True
        >>> 
        ```

??? python "Logarithme de recherche par dichotomie : Ã  savoir refaire ðŸ’š"

    ```python
    def recherche_dichotomique(ma_liste, valeur) :
        indice_debut = 0
        indice_fin = len(ma_liste) - 1
        while indice_debut <= indice_fin :  # (1)
            indice_centre = (indice_debut + indice_fin) // 2  # (2)
            valeur_centrale = ma_liste[indice_centre]
            if valeur_centrale == valeur :
                return indice_centre
            if valeur_centrale < valeur :
                indice_debut = indice_centre + 1  # (3)
            else :
                indice_fin = indice_centre - 1  # (4)
        return None
    ```

    1. :warning: Il faut bien `<=` et pas `<` 
    2. :warning: Il faut une division **entiÃ¨re** donc `//` et pas `/`
    3. ðŸ‘‰ On cherche Ã  droite
    4. ðŸ‘ˆ On cherche Ã  gauche

    !!! attention "Prenez le temps de lire les commentaires (cliquez sur les +)"



??? abstract "Terminaison de l'algorithme de recherche dichotomique"
    Est-on sÃ»r que l'algorithme va se terminer ?  
    La boucle `while` qui est utilisÃ©e doit nous inciter Ã  la prudence.  
    Il y a en effet le risque de rentrer dans une boucle infinie.  
    Pourquoi n'est-ce pas le cas ?

    **Aide :** observer la position des deux flÃ¨ches bleues lors de l'exÃ©cution de l'algorithme 
    ![image](images/fig4.png){: .center}


    La condition de la boucle `while` est `indice_debut <= indice_fin `, qui pourrait aussi s'Ã©crire `indice_fin >= indice_debut `.  
    Au dÃ©marrage de la boucle, on a :


    ```python
        indice_debut = 0
        indice_fin = len(L) - 1
    ```

    Ceci qui nous assure donc de bien rentrer dans la boucle. 

    Ensuite, Ã  chaque Ã©tape, les deux variables `indice_debut` et `indice_fin` vont se **rapprocher** jusqu'Ã  ce que le programme rencontre un `return` ou bien jusqu'Ã  ce que `indice_fin` devienne infÃ©rieur Ã  `indice_debut`.  

    Ceci nous assure donc que le programme va bien se terminer.

    ??? note "Variant de boucle"

        On dit que la valeur `indice_fin - indice_debut ` reprÃ©sente le **variant de boucle** de cet algorithme. 
        Ce variant est un nombre entier, d'abord strictement positif, puis qui va dÃ©croÃ®tre jusqu'Ã  la valeur 0.

{{exercice(titre="ComplexitÃ© de l'algorithme de recherche dichotomique")}}

    Nous allons considÃ©rer que la complexitÃ© est due au nombre d'Ã©tapes nÃ©cessaires pour obtenir le rÃ©sultat. 

    ??? question "Quel est le pire des cas de recherche dichotomique d'une valeur dans une liste triÃ©e ?"
        Le pire des cas est lorsque l'Ã©lÃ©ment n'est pas prÃ©sent dans la liste.


    ??? question "Combien d'Ã©tapes (au maximum) sont-elles nÃ©cessaires pour arriver Ã  la fin de l'algorithme ?"
        Imaginons que la liste initiale possÃ¨de 8 valeurs. 
        AprÃ¨s une Ã©tape, il ne reste que 4 valeurs Ã  traiter. 
        Puis 2 valeurs.  
        Puis une seule valeur.  
        Il y a donc 3 Ã©tapes avant de trouver la valeur cherchÃ©e.

    ??? question "Combien d'Ã©tapes en fonction de la taille de la liste ?"
        **1.** Remplissez le tableau ci-dessous :

        | taille de la liste | 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 
        | :----------------- |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
        | nombre d'Ã©tapes    | _ | _ |  _  |   3 |  _ | _   | _   | _   | 

        ??? success "Solution"

            | taille de la liste | 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 
            | :----------------- |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
            | nombre d'Ã©tapes    | 0 | 1 |  2  |   3 |  4 | 5  | 6  | 7   |

        **2.** Pouvez-vous deviner le nombre d'Ã©tapes nÃ©cessaires pour une liste de 4096 termes ?

        ??? success "Solution"

            12 Ã©tapes

        **3.** Pour une liste de $2^n$ termes, quel est le nombre d'Ã©tapes ?
        
        ??? success "Solution"

            $n$ Ã©tapes


    !!! info "Nombres d'Ã©tapes pour une liste de taille $n$"

        Sachant qu'Ã  chaque itÃ©ration de la boucle on divise Ã  peu prÃ¨s (division entiÃ¨re) le tableau en $2$, cela revient donc Ã  se demander combien de fois faut-il diviser le tableau en $2$ pour obtenir, Ã  la fin, un tableau comportant un seul Ã©lÃ©ment ?   
        ðŸ™ƒ Autrement dit, combien de fois faut-il diviser `n` par `2` pour obtenir `1` ?
        

    !!! info "Le logarithme en base 2"

        Une mesure de la complexitÃ© est donc le nombre $k$ tel que  $2^k=n$.

        Nous n'allons pas rentrer dans les dÃ©tails, mais il faut savoir qu'il existe une fonction mathÃ©matique (rÃ©ciproque de la fonction qui Ã  $x$ associe $2^x$) qui permet de rÃ©soudre ce problÃ¨me :   
        la fonction "logarithme en base 2" notÃ©e $\text{log}_2$  

        $k=\text{log}_2(n)$      

        ![log2](images/log2.png){ width=60% }

        La courbe en rouge correspond Ã  la complexitÃ© de la recherche dichotomique (logarithmique en base 2), et la droite verte Ã  celle de la recherche sÃ©quentielle (linÃ©aire).

    ??? danger "Attention calculatrices"

        les calculatrices ont une touche <kbd>log</kbd> et une touche <kbd>ln</kbd> qui donnent respectivement le logaritme en base 10, et le logarithme en base $\text{e}$.  
        On peut obtenir le rÃ©sultat du logarithme en base 2 d'un nombre de la faÃ§on suivante, par exemple pour calculer $\text{log}_2(1024)$ :  
        <kbd>(</kbd> <kbd>log</kbd> <kbd>1024</kbd> <kbd>)</kbd> <kbd>$\div$</kbd> <kbd>log</kbd> <kbd>2</kbd>  
        ou bien  
        <kbd>(</kbd> <kbd>ln</kbd> <kbd>1024</kbd> <kbd>)</kbd> <kbd>$\div$</kbd> <kbd>ln</kbd> <kbd>2</kbd>  

    ??? note "ComplÃ©ment sur les fonctions logarithme"

        * La fonction $\text{log}_2$ est la fonction rÃ©ciproque de celle qui Ã  tout rÃ©el $x$ associe $2^x$
        * La fonction $\text{log}$ est la fonction rÃ©ciproque de celle qui Ã  tout rÃ©el $x$ associe $10^x$
        * La fonction $\text{ln}$ est la fonction rÃ©ciproque de celle qui Ã  tout rÃ©el $x$ associe $\text{e}^x$

    ??? python "Le logarithme en base 2 en Python"

        En Python, il suffit d'importer la fonction `log2`

        Tester le script ci-dessous :

        {{ IDE('scripts/log2_python') }}


??? abstract "ComplexitÃ© logarithmique de la recherche dichotomique ðŸ’š A retenir"

    La recherche dichotomique se fait avec une **complexitÃ© logarithmique**.

    On rencontrera parfois la notation $O(\log_2(n))$.

    Le $O$ se prononce "grand O" (la lettre)

    Cette complexitÃ© est bien meilleure qu'une complexitÃ© linÃ©aire. Le nombre d'opÃ©rations Ã  effectuer est trÃ¨s peu sensible Ã  la taille des donnÃ©es d'entrÃ©e, ce qui en fait un algorithme trÃ¨s efficace.

    !!! warning "N'oubliez pas que dans le cas de la recherche dichotomique, **le tableau doit Ãªtre triÃ© !**"


{{exercice(titre="Temps de calcul")}}

    Recopier et exÃ©cuter le code suivant dans votre Ã©diteur python local (pas en ligne)

    ```python
    from timeit import timeit

    def dicho(tableau: list, x: int) -> bool :
        """
        :param tableau: une liste d'entiers triÃ©s par ordre croissant
        :param x: de type int
        :returns: bool : True si x est dans tableau, False sinon

        >>> dicho([1, 3, 4, 9], 4)
        True
        >>> dicho([1, 3, 4, 9], 11)
        False
        """
        deb = 0
        fin = len(tableau) - 1
        mil = (deb + fin) // 2

        while deb <= fin :

            if tableau[mil] ==  x:
                return True
            elif tableau[mil] < x:
                deb = mil + 1
            else :
                fin = mil - 1
            mil = (deb + fin) // 2
        return False

    tailles = [500, 2500, 12500, 62500]

    # tref est le temps de calcul pour une liste de taille 100
    liste_ref = [i for i in range(100)]
    tref = timeit("dicho(liste_ref, -1)", number = 1000, globals = globals())
    print("n = 100 -> tref = ",round(tref, 6))

    for n in tailles :
        print("n =", n, end='')
        tab = [i for i in range(n)]
        # Calcul du temps pour des listes triÃ©es de tailles n
        t = timeit("dicho(tab, -1)", number = 1000, globals = globals())

        print('\t-> temps = ',round(t, 6), '\t x', round(t/tref, 2) )
        tref = t
    ```

    ??? note pliÃ©e "Que remarque-t-on?"

        A chaque Ã©tape, n est multiliÃ© par 5, et on voit dans le tableau que le temps est multipliÃ© par un nombre trÃ¨s infÃ©rieur Ã  5.  


??? example "Un exemple spectaculaire de l'efficacitÃ© de la recherche par dichotomie"
    ![terre](images/Terre.png){ width=20%; : .center }

    Imaginons un annuaire qui contienne les noms, prÃ©noms, adresses.....des 7 milliards d'Ãªtres humains vivant sur la terre.

    ðŸ¤” Quel est le nombre maximum d'Ã©tapes pour trouver un individu ? 

    PlaÃ§ons nous dans le pire des cas.

    Comme Ã  chaque Ã©tape on divise le nombre de personne par 2, la question revient Ã  : **combien de fois faut-il que je divise 7 milliards par 2 pour qu'il n'en reste qu'un ?**

    Cela revient Ã  trouver $n$  tel que $\dfrac{7000000000}{2^n}=1$  , câ€™est Ã  dire $2^n=7000000000$ .

    A la calculatrice on voit que  $2^{32}=4294967296$ et que $2^{33}=8589934592$.

    Il faut donc au maximum 33 Ã©tapes

    ðŸŒµ Un algorithme qui balaye la liste du dÃ©but Ã  la fin aurait fait 1 Ã©tape pour la premiÃ¨re personne et 7 milliards d'Ã©tapes pour la derniÃ¨re !

    Un algorithme par parcours sÃ©quentiel de liste aurait nÃ©cessitÃ©, dans le pire des cas 7 milliards dâ€™Ã©tapes. Lâ€™algorithme par dichotomie qui n'en nÃ©cessite que 33 est donc Ã©normÃ©ment plus efficace.  

    !!! warning "Cependant"

        Cependant, il ne faut pas perdre de vue que dans le cas de la recherche dichotomique, **il est nÃ©cessaire d'avoir un tableau triÃ©**. 

        !!! danger "Attention"

            Si au dÃ©part le tableau n'est pas triÃ©, il faut rajouter la durÃ©e du tri.  


{{exercice(titre="ComplÃ©ter la fonction `dichotomie`")}}
    * prenant en paramÃ¨tre un tableau de nombres triÃ©s dans l'ordre croissant `nombres` et une valeur `cible`
    
    * renvoyant `True` si `cible` est une valeur de `nombres`, `False` dans le cas contraire.

    !!! example "Exemples"

        ```pycon
        >>> dichotomie([1, 2, 3, 4], 2)
        True
        >>> dichotomie([1, 2, 3, 4], 1)
        True
        >>> dichotomie([1, 2, 3, 4], 4)
        True
        >>> dichotomie([1, 2, 3, 4], 5)
        False
        >>> dichotomie([1, 2, 3, 4], 0)
        False
        >>> dichotomie([1], 1)
        True
        >>> dichotomie([1], 0)
        False
        >>> dichotomie([], 1)
        False

        ```

    !!! warning "Remarque"

        Vous utiliserez obligatoirement un algorithme de **recherche dichotomique**.
        

    ???+ question "ComplÃ©ter ci-dessous"

        {{ IDE('scripts/dicho_1') }}


{{exercice(titre="DÃ©terminer l'indice d'un nombre dans une liste")}}

    On considÃ¨re dans cet exercice des tableaux non vides contenant des nombres entiers, tous distincts, triÃ©s dans l'ordre croissant.

    On cherche Ã  dÃ©terminer l'indice d'une valeur `#!py cible` dans ce tableau Ã  l'aide d'une **recherche dichotomique** dans sa version itÃ©rative.

    Ã‰crire la fonction `#!py indice` qui prend en paramÃ¨tres le tableau de nombres `#!py tableau` et la valeur cherchÃ©e `#!py cible`.

    Si la `#!py cible` est dans le tableau, la fonction renverra son indice. Dans le cas contraire, la fonction renverra `None`.


    ???+ danger "Attention"

        Les tableaux des tests secrets peuvent Ãªtre trÃ¨s grands. Une recherche linÃ©aire naÃ¯ve prendrait trop de temps lors de l'exÃ©cution.

        Les tests secrets limitent le nombre de lectures dans le tableau Ã  100. Si votre code accÃ¨de Ã  plus de 100 valeurs dans le tableau, une erreur sera levÃ©e.


    ???+ example "Exemples"

        ```pycon
        >>> tableau = [23, 28, 29, 35, 37]
        >>> indice(tableau, 23)
        0
        >>> indice(tableau, 29)
        2
        >>> indice(tableau, 37)
        4
        >>> indice(tableau, 10)
        None
        >>> indice(tableau, 100)
        None
        ```

    ???+ question

        ComplÃ©ter le script ci-dessous :
        
        {{ IDE('scripts/dicho_2') }}


{{exercice(titre="Ã‰tude d'une panne")}}

    Une sonde interroge Ã  intervalles rÃ©guliers l'Ã©tat de fonctionnement d'un systÃ¨me Ã©lectronique. Celui-ci peut Ãªtre en marche ou en panne.

    La sonde est programmÃ©e pour enregistrer les rÃ©sultats de ses requÃªtes dans un *log*. Il s'agit d'un tableau de boolÃ©ens (une `#!py list` Python) dans lequel les valeurs `#!py True` prÃ©cÃ¨dent les `#!py False`. La valeur `#!py True` indique que le systÃ¨me est en marche, `#!py False` qu'il est en panne.

    Une panne nÃ©cessite une intervention humaine et ne peut donc pas disparaÃ®tre seule : elle persiste jusqu'Ã  la fin de l'enregistrement.

    ```python
    #         0     1      2      3      4
    log = [True, True, False, False, False]
    ```

    Lors d'une vÃ©rification on constate que le systÃ¨me est en panne : le *log* contient au moins une valeur `#!py False` en derniÃ¨re position. On se demande Ã  quel moment a dÃ©butÃ© cette panne.

    Dans l'exemple prÃ©cÃ©dent, le premier `#!py False` est Ã  l'indice `#!py 2` : la panne a dÃ©butÃ© Ã  l'instant `#!py 2`.

    Ã‰crire la fonction `#!py indice_panne` qui prend en paramÃ¨tre le tableau de boolÃ©ens `#!py log` et renvoie l'instant du dÃ©marrage de la panne.

    On garantit que le *log* n'est pas vide et que, au moment de la vÃ©rification, le systÃ¨me est en panne (la derniÃ¨re valeur du tableau est `False`).

    ???+ danger "Attention"

        La panne du systÃ¨me a aussi corrompu le fichier de *log*. Vous ne pouvez pas lire plus de 500 valeurs dans celui-ci. PassÃ© ce nombre de lectures, tout nouvel accÃ¨s lÃ¨vera une erreur.

        Il est donc important de bien concevoir votre algorithme car les *logs* utilisÃ©s dans les tests secrets peuvent Ãªtre trÃ¨s longs : un milliard de valeurs !

    ???+ example "Exemples"

        ```pycon
        >>> indice_panne([True, False])
        1
        >>> indice_panne([False, False, False])
        0
        >>> indice_panne([True] * 10 + [False] * 100)
        10
        >>> indice_panne([True, True, False, False, False])
        2
        ``` 

    ???+ question

        ComplÃ©ter le script ci-dessous :   

        {{ IDE('scripts/panne') }}

    ??? tip "Astuce (1)"

        Il s'agit d'une recherche dans un tableau triÃ© : les valeurs `#!py True` sont au dÃ©but, les `#!py False` Ã  la fin.

    ??? tip "Astuce (2)"

        Si le *log* ne contient que des valeurs `#!py False`, il faut renvoyer `#!py 0`. 
        
        Dans le cas contraire, l'indice cherchÃ© est l'unique indice `#!py i` qui vÃ©rifie `#!py log[i - 1] and not log[i]`.
